Перейдём в консоль и посмотрим на манифест ServiceAccount'а:

kubectl get serviceaccount

Видим ServiceAccount default

Свой сервис аккаунт default есть в каждом неймспейсе, он создаётся автоматически. По умолчанию прав у этого аккаунта на доступ к API нет никаких.
Смотрим внутрь:
kubectl get sa default -o yaml

Видим служебные поля и имя. Имя — это и есть то, что мы указываем при создании  ServiceAccount. В поле secret лежит название секрета с токеном. Это поле добавляется контроллером автоматически.

Если посмотреть в secret, увидим там корневой сертификат кластера ca.crt. Он нужен,  чтобы клиент был уверен, что он связывается именно с тем кластером, с которым надо. Есть поле namespace — оно показывает, в каком неймспейсе создан сервис аккаунт. И есть токен, с которым собственно и делаются запросы к API. Токен передаётся в заголовках HTTP-запроса.

Вы можете создать свой сервис аккаунт и указать его имя в манифесте пода, тогда при запуске контейнеров пода в них будет смонтирован секрет с токеном от этого сервис аккаунта. Если ServiceAccount не указывать, то будет смонтирован секрет от сервис аккаунта default. 

Иногда говорят, что под в кластере Kubernetes работает с правами сервис аккаунта. Это приводит к путанице и проблемам в понимании принципов работы. Под нигде не работает, работает приложение. Приложение запущено в контейнерах пода на воркер-узлах и работает там как обычный Linux-процесс в самоизоляции. Всё!

Единственное, что происходит в кластере Kubernetes — kubelet монтирует токен внутрь контейнеров. И дальше уже приложение решает: если ему нужно обращаться к API кластера, будет ли оно брать токен из этого смонтированного секрета или возьмёт другой токен, например, запросит у пользователя.